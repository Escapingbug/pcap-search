#!/bin/zsh
set -e -u
setopt nullglob

program=$0
dshell_defcon=${0:a:h}/dshell-defcon
pcap_suffix=.cap
ap_suffix=.ap

usage() {
  cat <<e
Usage: ${program##*/} dir
Transform .cap files into .ap files

Options:
  -p max-procs   Run up to max-procs dshell-decode at a time (currently by detecting python2 processes, inaccurate)
e
  exit $1
}

log_generic() {
  fmt=$1
  print -- "$(date +%T.%N) $fmt" "${@:2}"
}
log_error() { tput setaf 1; log_generic "$@"; tput sgr0 }
log_action() { tput setaf 2; log_generic "$@"; tput sgr0 }
log_status() { tput setaf 3; log_generic "$@"; tput sgr0 }
log_event() { tput setaf 6; log_generic "$@"; tput sgr0 }

declare -A modified
add() { modified[$1]=1 }
del() { unset "modified[$1]" }

semaphore() {
  seq $parallel
  while read; do
    echo
  done
}

add_data() {
  filename=$1
  log_status found $filename
  (
    read -p
    start=$(date +%s.%N)
    $dshell_defcon/dshell-decode -d stream2dump --stream2dump_outfiles=$filename$ap_suffix $filename >/dev/null
    stop=$(date +%s.%N)
    log_action created $ap_suffix for $filename, size: $(stat -c %s $filename), used $(bc -l<<<"scale=3;($stop-$start)/1") s
    print -p
  ) &
}

rm_data() {
  rm -fv $filename$ap_suffix
}

parallel=$(nproc)
while getopts h opt; do
  case $opt; in
    h) usage 0;;
    p) parallel=$OPTIND;;
    \?) exit;;
  esac
done

dir=${1:-}
if [[ -z $dir ]]; then
  usage 1
fi
cd $dir

coproc semaphore

log_status processing $dir

for i in *$pcap_suffix; do
  [[ -e $i$ap_suffix && ! -z $i$ap_suffix ]] || add_data $i
done

log_status start inotify

inotifywait -mqe CREATE,CLOSE_WRITE,DELETE,MODIFY,MOVE --format $'%e\t%f' . | while IFS=$'\t' read -r event filename; do
  [[ $filename =~ "\\$pcap_suffix\$" ]] || continue
  if [[ $event =~ CREATE ]]; then
    log_event CREATE $filename
    if filetype=$(stat -c %F $filename); then
      if [[ $filetype =~ symbolic ]]; then
        add_data $filename
      else
        add $filename
      fi
    fi
  elif [[ $event =~ DELETE ]]; then
    log_event DELETE $filename
    del $filename
    rm_data $filename
  elif [[ $event =~ MOVED_FROM ]]; then
    log_event MOVED_FROM $filename
    del $filename
    rm_data $filename
  elif [[ $event =~ MOVED_TO ]]; then
    log_event MOVED_TO $filename
    add_data $filename
  elif [[ $event =~ MODIFY ]]; then
    log_event MODIFY $filename
    add $filename
  elif [[ $event =~ CLOSE_WRITE ]]; then
    if [[ -n ${modified[$filename]} ]]; then
      log_event CLOSE_WRITE after MODIFY $filename
      del $filename
      add_data $filename
    else
      log_event CLOSE_WRITE $filename
    fi
  fi
done
